

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/mad.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="i4G5d">
  <meta name="keywords" content="">
  
    <meta name="description" content="Web缓存中毒（Web Cache Deception） Web缓存欺骗 是通过构造并发送恶意URL链接，让受害者写入本不会写入缓存的敏感信息，然后攻击者读取包含敏感信息的缓存； Web缓存中毒则是利用服务器和缓存的行为向受害者提供有害的http响应 1. 成功的缓存中毒攻击可以结合其他攻击（利用XSS、JavaScript注入、开放重定向等漏洞） 2.  受害页面的流量越大，缓存中毒影响越大">
<meta property="og:type" content="article">
<meta property="og:title" content="web缓存中毒">
<meta property="og:url" content="https://i4g5d.github.io/2025/10/19/web-cache2/index.html">
<meta property="og:site_name" content="i4G5d-Blog">
<meta property="og:description" content="Web缓存中毒（Web Cache Deception） Web缓存欺骗 是通过构造并发送恶意URL链接，让受害者写入本不会写入缓存的敏感信息，然后攻击者读取包含敏感信息的缓存； Web缓存中毒则是利用服务器和缓存的行为向受害者提供有害的http响应 1. 成功的缓存中毒攻击可以结合其他攻击（利用XSS、JavaScript注入、开放重定向等漏洞） 2.  受害页面的流量越大，缓存中毒影响越大">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019160244128.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019163150920.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019164809221.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019164728032.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019164909372.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019165939123.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019171132050.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019172045889.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019172115792.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019172305722.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019173507838.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019174500644.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019174545379.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019212731043.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019213047929.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019213637558.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019214823087.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019215028032.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019221456484.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019223253040.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019223713016.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019223943642.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019224745183.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019224804961.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019225749175.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019230747306.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019235312055.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020001153373.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020001232985.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020001332616.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020001508617.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020001532956.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020004819824.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020010135230.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020010209338.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020010311507.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020010600701.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020011838792.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020012614585.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020012600278.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020012900595.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020013450157.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020014022161.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020014926501.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020015114611.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251020234237627.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021135837393.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021154310398.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021154459096.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021154907912.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021155045778.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021155530718.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021155931847.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021160901496.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021161505595.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021170747697.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021175304760.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021172854852.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021175414661.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021180107389.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021182615351.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021183403414.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021184230894.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021200313309.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021201642529.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021203648428.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021204732618.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021213548810.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021214702490.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021214844498.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021215204347.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251021215251132.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022000832522.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022001511224.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022001945132.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022131241426.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022133014385.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022133043230.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022005137856.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022142539263.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022143132989.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022143359296.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022144056001.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022143601254.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022145502171.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022224243100.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022224322649.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022224333102.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022230955752.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022235502970.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022235635261.png">
<meta property="og:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251022235722362.png">
<meta property="article:published_time" content="2025-10-19T07:24:08.000Z">
<meta property="article:modified_time" content="2025-10-22T16:53:01.916Z">
<meta property="article:author" content="i4G5d">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i4g5d.github.io/2025/10/19/web-cache2/image-20251019160244128.png">
  
  
  
  <title>web缓存中毒 - i4G5d-Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"i4g5d.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>i4G5d</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="web缓存中毒"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-19 15:24" pubdate>
          2025年10月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          96 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">web缓存中毒</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Web缓存中毒（Web-Cache-Deception）"><a href="#Web缓存中毒（Web-Cache-Deception）" class="headerlink" title="Web缓存中毒（Web Cache Deception）"></a><strong>Web缓存中毒</strong>（Web Cache Deception）</h1><p><img src="/2025/10/19/web-cache2/image-20251019160244128.png" srcset="/img/loading.gif" lazyload></p>
<p><a href="https://i4g5d.github.io/2025/10/15/web-cache/">Web缓存欺骗</a> 是通过构造并发送恶意URL链接，让受害者写入本不会写入缓存的敏感信息，然后攻击者读取包含敏感信息的缓存；</p>
<p>Web缓存中毒则是利用服务器和缓存的行为向受害者提供有害的http响应</p>
<pre><code class="hljs">1. 成功的缓存中毒攻击可以结合其他攻击（利用XSS、JavaScript注入、开放重定向等漏洞）
2.  受害页面的流量越大，缓存中毒影响越大
</code></pre>
<h2 id="利用缓存设计缺陷："><a href="#利用缓存设计缺陷：" class="headerlink" title="利用缓存设计缺陷："></a>利用缓存设计缺陷：</h2><p> 我总结下来就是利用非密钥输入，（例如 HTTP 标头和 Cookie）来利用 Web 缓存投毒漏洞</p>
<ol>
<li><p>发起XSS攻击 </p>
<p>利用一些标头的非加密性，例如<code>X-Forwarded-Host</code>（<code>X-Forwarded-Host</code>被用来动态生成 Open Graph 图片 URL，然后将其反映在响应中。对于 Web 缓存中毒而言，至关重要的是<code>X-Forwarded-Host</code>标头通常是无密钥的。）</p>
<p>正常模式：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /en?<span class="hljs-attribute">region</span>=uk HTTP/1.1 <br>Host: innocent-website.com <br>X-Forwarded-Host: innocent-website.co.uk <br><br>HTTP/1.1 200 OK <br>Cache-Control: public &lt;meta <span class="hljs-attribute">property</span>=<span class="hljs-string">&quot;og:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;https://innocent-website.co.uk/cms/social.png&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>那就可以构造</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">X-Forwarded-Host: a.&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&quot;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:image&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;https://a.&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&quot;/cms/social.png&quot; /&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>利用资源导入的不安全处理</p>
<p> 将URL指向自己的恶意js文件</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>innocent-website.com<br><span class="hljs-attribute">X-Forwarded-Host</span><span class="hljs-punctuation">: </span>evil-user.net<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 Firefox/57.0<br><br><span class="language-apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK</span><br><span class="language-apache"><span class="hljs-section">&lt;script src=<span class="hljs-string">&quot;https://evil-user.net/static/analytics.js&quot;</span>&gt;</span><span class="hljs-section">&lt;/script&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>1和2通常一起考虑 在XFH进行恶意注入 如果直接注入xss等无效 就用资源导入 导入攻击者的JS文件写入cache</p>
</li>
<li><p>Web 缓存中毒利用 Cookie 处理漏洞</p>
</li>
</ol>
<p>   这种很少见，简单带过。就是往往缓存键不包括cookie ,如果cookie的信息会得到相应的响应，或cookie本就有构造的价值，就能写入缓存攻击</p>
<ol start="4">
<li><p>使用多个标头</p>
<p>网站肯定不会向上面说的那么简单就收到缓存中毒，那就要结合所谓的<strong>多头联合投毒</strong></p>
<p>比如服务器的 redirect 逻辑是这样（伪代码）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> req.<span class="hljs-property">header</span>[<span class="hljs-string">&#x27;X-Forwarded-Proto&#x27;</span>] == <span class="hljs-string">&#x27;http&#x27;</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">301</span> <span class="hljs-title class_">Location</span>: <span class="hljs-string">&quot;https://&quot;</span> + req.<span class="hljs-property">header</span>[<span class="hljs-string">&#x27;Host&#x27;</span>] + req.<span class="hljs-property">path</span><br></code></pre></td></tr></table></figure>

<p>攻击者控制两个未纳入 cache key 的输入：</p>
<ul>
<li><code>X-Forwarded-Proto: http</code></li>
<li><code>X-Forwarded-Host: attacker.example.com</code></li>
</ul>
<p>服务器返回</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">301</span> Moved Permanently<br><span class="hljs-attribute">Location</span><span class="hljs-punctuation">: </span>https://attacker.example.com/random<br></code></pre></td></tr></table></figure>

<p>缓存把这个 301 缓存（且 cache key 只基于 Host+path，不包含 X-Forwarded-*），</p>
<p>那么后续普通访问 <code>GET /random</code>（不带这些 headers）会被边缘节点以缓存返回 <strong>301 Location: <a target="_blank" rel="noopener" href="https://attacker.example.com/random">https://attacker.example.com/random</a></strong> → 所有用户都被重定向到攻击者站点。</p>
<p>（在做实验时，找攻击的文件时，要注意找个原本就是解析js语句的文件，因为实验要求是执行<code>alert</code>）</p>
</li>
<li><p>利用相应暴露的信息</p>
<p>一个是类似<code>max-age=1800</code>包含有关清除缓存的频率或当前缓存的响应有多久的信息；一个是Vary标头，这个标头定义哪些请求头算进cache key 例如：Vary: User-Agent。</p>
</li>
<li><p>利用基于 DOM 的漏洞</p>
<p>这和第2点像，2是导入攻击者的静态文件，而这里是利用DOM进行导入；</p>
<p>如果一个站点会从某个 URL 加载数据（例如 JSON），并在客户端不经安全清理地把这些数据放进 DOM&#x2F;执行，那么攻击者可以通过<strong>污染该 URL 的缓存内容</strong>（使其返回恶意 JSON&#x2F;脚本）来让所有普通用户加载并在浏览器中触发 DOM 型漏洞。</p>
<p>比如网站直接读取json，我们将读取的文件改成自己构造的json,随后进行写Cache，但是记得同源策略，自己服务器上加入Access-Control-Allow-Origin: *</p>
</li>
<li><p>链接式 Web 缓存投毒漏洞</p>
<p>正如我们之前所见，有时攻击者只能通过使用多个标头精心构造请求来引发恶意响应。但不同类型的攻击也存在同样的情况。Web 缓存投毒有时需要攻击者将我们讨论过的几种技术串联起来。通过串联不同的漏洞，通常可以暴露最初无法利用的额外漏洞层。后面有实验能反应这种情况</p>
</li>
</ol>
<h2 id="利用缓存实现方式的缺陷！："><a href="#利用缓存实现方式的缺陷！：" class="headerlink" title="利用缓存实现方式的缺陷！："></a>利用缓存实现方式的缺陷！：</h2><p>用非密钥方式的方式只是皮毛，这里利用缓存系统特定实现中的缺陷，扩大 Web 缓存投毒的攻击面。</p>
<h3 id="缓存键缺陷"><a href="#缓存键缺陷" class="headerlink" title="缓存键缺陷"></a>缓存键缺陷</h3><p>​	我们在写入缓存时，通常不会考虑加上payload,因为我们会认为这是受害者基本很难触发读Cache的。</p>
<p>​	但实际CDN&#x2F;缓存&#x2F;代理&#x2F;应用经常对这些“keyed”组件做变换（去掉 query、过滤特定参数、规范化顺序或大小写等），从而产生键与应用处理输入之间的不一致。</p>
<h3 id="缓存探测方法（探索缺陷3步骤）"><a href="#缓存探测方法（探索缺陷3步骤）" class="headerlink" title="缓存探测方法（探索缺陷3步骤）"></a>缓存探测方法（探索缺陷3步骤）</h3><ol>
<li><p>识别合适的 cache oracle（必须）</p>
<p><strong>目的</strong>：找到一个“能告诉你缓存是否命中”的端点（称作 oracle），它应满足：</p>
<ul>
<li><strong>可被缓存</strong>（<code>Cache-Control</code>&#x2F;状态头显示可缓存或你观测到 <code>Age/X-Cache</code>），</li>
<li><strong>响应会反映你发的输入</strong>（能把你放在 URL&#x2F;header&#x2F;query 的 token 反映回响应 body 或 header），</li>
<li><strong>能通过响应头或时间差判断 hit&#x2F;miss</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先 probe（确认“干净”）</span><br><br>curl -I <span class="hljs-string">&quot;https://target.example.com/path?cb=PROBE123&quot;</span><br><br><span class="hljs-comment"># 观察响应头：X-Cache / Age / Cache-Control / CF-Cache-Status</span><br></code></pre></td></tr></table></figure>

<p>如果有指纹信息，查文档找，例如：</p>
<p>如果站点使用特定 CDN（Akamai 等），查文档看是否能直接请求显示 cache key（例如 <code>Pragma: akamai-x-get-cache-key</code>）。</p>
</li>
<li><p>探测 key handling</p>
<p><strong>目标</strong>：找出缓存在生成 cache key 时做了哪些<strong>额外处理</strong>（比如去掉 query、过滤特定参数、规范化端口&#x2F;大小写、排序参数、解码行为等）。</p>
<details>
  <summary><b>📘 点击展开解释</b></summary>

<p>常见检测向量（每个向量都用 probe→test→compare）</p>
<ol>
<li>是否完全忽略 query string？</li>
</ol>
<p>对比 GET &#x2F;p?cb&#x3D;1&amp;a&#x3D;1 与 GET &#x2F;p?cb&#x3D;2&amp;a&#x3D;2 的 cache 行为（probe 后，注入 token 再读）。</p>
<ol start="2">
<li>是否过滤特定参数（utm_*、_ga、fbclid）？</li>
</ol>
<p>把 token 放在 ?utm_source&#x3D;TOKEN 等，写入后读 &#x2F;p 看是否命中。</p>
<ol start="3">
<li>Host&#x2F;Port 是否被规范化（端口是否被剔除）？</li>
</ol>
<p>先请求 Host: host:1337，观察 Location 包含 :1337（回显）。然后请求 Host: host 看是否返回缓存带 :1337 的 Location（如教材例子）。</p>
<ol start="4">
<li>参数排序&#x2F;大小写&#x2F;编码是否规范化？</li>
</ol>
<p>比较 ?a&#x3D;1&amp;b&#x3D;2 与 ?b&#x3D;2&amp;a&#x3D;1，以及 %2F vs &#x2F; 的变体。</p>
<ol start="5">
<li>是否对部分 header 做 key-normalize 或 strip？</li>
</ol>
<p>注入 header（X-Forwarded-Host、Origin）并观察是否会被反射与缓存。</p>
</details>
</li>
<li><p>识别 exploitable gadget（选择“有用”的漏洞点）</p>
<p><strong>为什么要找 gadget？</strong> 缓存键缺陷只是让你能写入“被共享的缓存条目”，但真正能造成危害的，是缓存里的内容会怎样被客户端或服务端“消费”——即 gadget。</p>
<p>高价值 gadget：</p>
<ul>
<li><strong>反射 XSS 点</strong>（把输入原样注入到 HTML&#x2F;JS 中）→ 缓存中毒后变成 stored XSS。</li>
<li><strong>可控 Location &#x2F; redirect</strong> → 缓存中毒后可把普通 URL 变成全局 redirect。</li>
<li><strong>动态资源（JSON&#x2F;JS）</strong>：应用把 JSON 字段插入 innerHTML 或 <code>eval</code>，或把 JS 文件当作静态资源缓存（极易造成执行）。</li>
<li><strong>HTML snippet&#x2F;fragment 请求</strong>（page fragment 被缓存并注入到页面）</li>
</ul>
<p><strong>识别方法</strong>：</p>
<ul>
<li>在页面找 <code>fetch</code>&#x2F;XHR&#x2F;innerHTML&#x2F;innerText&#x2F; document.write &#x2F; eval &#x2F; script src 动态生成点。</li>
<li>在 HTML 模板中找是否会反射 query&#x2F;header 到 DOM（查看源码或抓包响应）。</li>
<li>优先选“静态可缓存且会被执行&#x2F;插入”的资源（如 tracking.js）。</li>
</ul>
</li>
</ol>
<h2 id="利用缓存键缺陷："><a href="#利用缓存键缺陷：" class="headerlink" title="利用缓存键缺陷："></a>利用缓存键缺陷：</h2><ol>
<li><h3 id="无密钥端口"><a href="#无密钥端口" class="headerlink" title="无密钥端口"></a>无密钥端口</h3><p>这就是上面步骤2中的第3点</p>
<p>比如cache key中不包含HOST表头，所以可以构造HOST,让受害者在正常访问时读到你构造的HOST。</p>
<p>能造成的攻击，通常是重定向到新端口，或者js文件如果是直接在DOM拼接，就可以构造出xss攻击</p>
</li>
<li><h3 id="无键查询字符串（Unkeyed-query-string）"><a href="#无键查询字符串（Unkeyed-query-string）" class="headerlink" title="无键查询字符串（Unkeyed query string）"></a>无键查询字符串（Unkeyed query string）</h3><p>常见的 cache key 组成：cache key &#x3D; [HTTP 方法] + [URL 路径] + [查询字符串（query string）] + [Host 头]</p>
<p>有些缓存系统出于性能考虑，会在生成缓存键时 <strong>忽略查询字符串（?后面的部分）</strong></p>
<p>若构造出：就达成目的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">GET</span> /?msg=<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>要是cache是按正常情况下把参数也放入rules，就可以再试试找有没有个别被屏蔽的参数，比如UTM参数，（用Param Miner去扫参数是能扫出来的）</p>
<p>还有如果<strong>Pragma: akamai-x-get-cache-key</strong>能用，甚至可能得到key</p>
</li>
<li><h3 id="缓存参数隐藏"><a href="#缓存参数隐藏" class="headerlink" title="缓存参数隐藏"></a>缓存参数隐藏</h3><p>这里我的理解就是在2 的基础上（通过参数得到攻击机会），服务器和Cache都保留参数，但可能存在差异，比如</p>
<p>构造&#x2F;<code>?a=1?b=2</code>,</p>
<ul>
<li><p>Cache会把第二个<code>?</code>后的排除，</p>
</li>
<li><p>而服务器把这一整句当做同一个参数，</p>
</li>
<li><p>这样就能让受害者读到a&#x3D;1的cache，而我们构造<code>?a=1?b=payload</code>的攻击。</p>
</li>
</ul>
<p>再比如  <code>/?a=1&amp;b=2;a=PAYLOAD</code>（Rails风格）</p>
<ul>
<li>Cache只认识 <code>&amp;</code>,只留下a&#x3D;1</li>
<li>服务器解析所有,并在存在重复参数情况下优先解析最后一个</li>
</ul>
<p>用这个思想也能利用JSONP（CORS的前辈），这是一种<strong>跨域数据请求的解决方案</strong>。他能用callback控制数据调用的函数名，通过用callback覆盖函数名为alert写入缓存就能完成xss。</p>
</li>
<li><h3 id="规范化Cache-rules"><a href="#规范化Cache-rules" class="headerlink" title="规范化Cache rules"></a>规范化Cache rules</h3><p>当你在参数中发现反射型 XSS 漏洞时，它实际上通常是无法利用的。因为现代浏览器在发送请求时通常会对必要的字符进行 URL 编码，而服务器不会对其进行解码。</p>
<p>但一些缓存实现在将带键的输入添加到缓存键时会对其进行规范化。在这种情况下，以下两个请求将具有相同的键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">GET</span> /example?param=<span class="hljs-string">&quot;&gt;&lt;test&gt; </span><br><span class="hljs-string">GET /example?param=%22%3e%3ctest%3e</span><br></code></pre></td></tr></table></figure>

<p>即使服务器会编码一些语句阻止xss攻击，但是Cache可能会做规范化，（将编码前后认为是同一个key）然后对上了之前写入的缓存</p>
</li>
<li><h3 id="缓存键注入"><a href="#缓存键注入" class="headerlink" title="缓存键注入"></a>缓存键注入</h3><p>缓存键通常由若干组件拼接而成（例如 <code>path__Host__Accept</code>），如果拼接时<strong>不对组件里的分隔符进行转义&#x2F;分隔保护</strong>，攻击者可以把恶意内容“注入”到一个键组件里，造成两个原本不同请求被映射到相同的 cache key，从而实现缓存中毒或把 payload 通过普通 URL 分发给所有用户。</p>
<p>具体操作，比如 key：<code>path</code> $$ <code>origin</code>$$</p>
<p>于是你可以通过构造origin形成CRLF注入，或者构造成我们需要的key</p>
</li>
<li><h3 id="毒害内部缓存"><a href="#毒害内部缓存" class="headerlink" title="毒害内部缓存"></a>毒害内部缓存</h3><ul>
<li><strong>粒度更小</strong>：很多应用会把页面拆成多个可复用 <strong>片段（fragment &#x2F; snippet &#x2F; fragment cache）</strong> 并单独缓存这些片段（例如页头、脚本片段、广告区、语言包片段等）。</li>
<li><strong>无或弱 cache key</strong>：这些片段往往旨在“可复用”，可能没有严格的键策略或键很宽泛——<strong>一旦污染，会影响所有使用该片段的页面</strong>（不是单一 URL）。</li>
<li><strong>行为不标准、难以预测</strong>：内部缓存是应用自定义实现，可能在编码、解析、权限、有效性上有奇怪行为（例如对 header 解码、边界没有转义、fragment 按 header 值直接索引等）。</li>
<li><strong>难以发现</strong>：因为不是外部 CDN，客户端通常看不到 <code>X-Cache</code> &#x2F; <code>Age</code> 这类头；污染迹象更多体现在“响应混合来自不同时间的输入”上。</li>
</ul>
<p>举例后果：把一个常在每页注入 <code>&lt;script src=&quot;/shared/tracking.js&quot;&gt;</code> 的 fragment 污染成带恶意代码的脚本，等于一次投毒影响整个站点，范围巨大。</p>
<p>常见被缓存的片段类型（攻击面）</p>
<ul>
<li>页面头&#x2F;尾 HTML 片段（nav、header、footer）</li>
<li>多语言或本地化 JS（<code>/js/localize.js</code>）</li>
<li>通用 script&#x2F;include（tracking、analytics、widget）</li>
<li>模板片段（广告位、推荐块）</li>
<li>JSON 配置片段（供前端 fetch）</li>
<li>Server-side rendered partials（共享组件）</li>
</ul>
</li>
</ol>
<h2 id="预防放毒："><a href="#预防放毒：" class="headerlink" title="预防放毒："></a>预防放毒：</h2><ol>
<li>不要缓存动态或用户专属内容</li>
<li>不要把不可信输入直接纳入 cache-key（或裸拼接）</li>
<li>在边缘层（CDN&#x2F;Proxy）对可被缓存的字段做严格白名单</li>
<li>统一cache和源服务器的解析方式</li>
<li>对输入，输出，DOM回显做编码处理</li>
</ol>
<h2 id="模拟靶场："><a href="#模拟靶场：" class="headerlink" title="模拟靶场："></a>模拟靶场：</h2><h3 id="实验室：使用未加密的标头进行-Web-缓存中毒"><a href="#实验室：使用未加密的标头进行-Web-缓存中毒" class="headerlink" title="实验室：使用未加密的标头进行 Web 缓存中毒"></a>实验室：使用未加密的标头进行 Web 缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251019163150920.png" srcset="/img/loading.gif" lazyload></p>
<p>直接甩给param Miner去扫header标头，</p>
<p> <img src="/2025/10/19/web-cache2/image-20251019164809221.png" srcset="/img/loading.gif" lazyload><img src="/2025/10/19/web-cache2/image-20251019164728032.png" srcset="/img/loading.gif" lazyload></p>
<p>于是加个X-forwarded-Host，在响应中能找到直接反射</p>
<p><img src="/2025/10/19/web-cache2/image-20251019164909372.png" srcset="/img/loading.gif" lazyload></p>
<p>于是尝试各种构造出xss注入的方式</p>
<p><img src="/2025/10/19/web-cache2/image-20251019165939123.png" srcset="/img/loading.gif" lazyload></p>
<p>但网页根本不给弹窗，改变思路，可能是利用资源导入漏洞,既然，既然服务器会直接读取这个静态文件，那试试通过构造让服务器读取我们的欺骗网址，里面写入xss语句</p>
<p><img src="/2025/10/19/web-cache2/image-20251019171132050.png" srcset="/img/loading.gif" lazyload></p>
<p>不知道为什么不能加其他字符串 只有里面没有类似于helloword的普通字符串才行，有可能是解析文件是直接放入script标签内</p>
<p>然后再自己独有的URL上测试 ，发包写入缓存</p>
<p><img src="/2025/10/19/web-cache2/image-20251019172045889.png" srcset="/img/loading.gif" lazyload></p>
<p>然后访问URL。成功读取Cache<img src="/2025/10/19/web-cache2/image-20251019172115792.png" srcset="/img/loading.gif" lazyload></p>
<p>最后只要再访问量最大的那个网页上写入缓存，等待后续有人读缓存就能达成目的 解开实验，那流量最大的肯定是首页啊</p>
<p><img src="/2025/10/19/web-cache2/image-20251019172305722.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="实验室：使用未加密的-cookie-进行-Web-缓存中毒"><a href="#实验室：使用未加密的-cookie-进行-Web-缓存中毒" class="headerlink" title="实验室：使用未加密的 cookie 进行 Web 缓存中毒"></a>实验室：使用未加密的 cookie 进行 Web 缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251019173507838.png" srcset="/img/loading.gif" lazyload></p>
<p>抓包发现，cookie内的内容会放到相应中，且题目说了cache不在缓存键中</p>
<p><img src="/2025/10/19/web-cache2/image-20251019174500644.png" srcset="/img/loading.gif" lazyload></p>
<p>那就直接构造javascript语法</p>
<p><img src="/2025/10/19/web-cache2/image-20251019174545379.png" srcset="/img/loading.gif" lazyload></p>
<p>再把路径改到主页 写入这个Cache即可</p>
<h3 id="实验室：具有多个标头的-Web-缓存中毒"><a href="#实验室：具有多个标头的-Web-缓存中毒" class="headerlink" title="实验室：具有多个标头的 Web 缓存中毒"></a>实验室：具有多个标头的 Web 缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251019212731043.png" srcset="/img/loading.gif" lazyload></p>
<p>当访问my-account路由时，发现了重定向</p>
<p><img src="/2025/10/19/web-cache2/image-20251019213047929.png" srcset="/img/loading.gif" lazyload></p>
<p>根据提示使用XFH和XFS时，跟随重定向，发现了重定向的规律</p>
<p><img src="/2025/10/19/web-cache2/image-20251019213637558.png" srcset="/img/loading.gif" lazyload></p>
<p>经过测试得到结论：只要XFS不是HTTPS,就都会重定向，且重定向可用XFH指定。</p>
<p>服务器的特性找到了，接下来看到目标里面有没有能执行XSS（原来就是执行js的文件）的文件：</p>
<p>根目录响应中，这句说明了会把这个文件当 JavaScript执行，且看到里面也只有一句，和我们要构造的几乎一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;/resources/js/tracking.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><img src="/2025/10/19/web-cache2/image-20251019214823087.png" srcset="/img/loading.gif" lazyload></p>
<p>拿出这个包：<img src="/2025/10/19/web-cache2/image-20251019215028032.png" srcset="/img/loading.gif" lazyload></p>
<p>这样的话 会重定向到我们攻击者服务器，且会按原来的运行逻辑访问<code>resources/js/tracking.js</code>随后执行<code>javascript</code>脚本</p>
<p>cache服务器把<code>lab/resources/js/tracking.js</code>作为缓存键，所以访问时，把重定向响应存到了cache。</p>
<h3 id="实验室：使用未知标头进行有针对性的-Web-缓存投毒"><a href="#实验室：使用未知标头进行有针对性的-Web-缓存投毒" class="headerlink" title="实验室：使用未知标头进行有针对性的 Web 缓存投毒"></a>实验室：使用未知标头进行有针对性的 Web 缓存投毒</h3><p><img src="/2025/10/19/web-cache2/image-20251019221456484.png" srcset="/img/loading.gif" lazyload></p>
<p>按照题目的要求，我们要做的  一个是获得特定用户的UA，一个是在Cache中写入alert(document.cookie)</p>
<p><img src="/2025/10/19/web-cache2/image-20251019223253040.png" srcset="/img/loading.gif" lazyload></p>
<p>但不奏效，那就看看有没有原网站能生效的写法</p>
<p><img src="/2025/10/19/web-cache2/image-20251019223713016.png" srcset="/img/loading.gif" lazyload></p>
<p>构造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;img src=<span class="hljs-string">&quot;https://exploit-0a3f00fe037fbbbe80790cc601e500af.exploit-server.net/test&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>看攻击者服务器日志拿到UA<img src="/2025/10/19/web-cache2/image-20251019223943642.png" srcset="/img/loading.gif" lazyload></p>
<p>用param Miner扩展猜测标头，得到几个<img src="/2025/10/19/web-cache2/image-20251019224745183.png" srcset="/img/loading.gif" lazyload><img src="/2025/10/19/web-cache2/image-20251019224804961.png" srcset="/img/loading.gif" lazyload></p>
<p>选择用X-Host看，发现是有回显的</p>
<p><img src="/2025/10/19/web-cache2/image-20251019225749175.png" srcset="/img/loading.gif" lazyload></p>
<p>把test换成攻击服务器，攻击服务器中写入alert语句，测试成功（为了完成实验 记得把UA换成前面截取到的）</p>
<p><img src="/2025/10/19/web-cache2/image-20251019230747306.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="实验室：通过具有严格缓存标准的缓存利用-Web-缓存中毒来利用-DOM-漏洞"><a href="#实验室：通过具有严格缓存标准的缓存利用-Web-缓存中毒来利用-DOM-漏洞" class="headerlink" title="实验室：通过具有严格缓存标准的缓存利用 Web 缓存中毒来利用 DOM 漏洞"></a>实验室：通过具有严格缓存标准的缓存利用 Web 缓存中毒来利用 DOM 漏洞</h3><p><img src="/2025/10/19/web-cache2/image-20251019235312055.png" srcset="/img/loading.gif" lazyload></p>
<p> 把根目录发给para Miner找标头<img src="/2025/10/19/web-cache2/image-20251020001153373.png" srcset="/img/loading.gif" lazyload></p>
<p>尝试写入，得到我们更改的data json数据</p>
<p><img src="/2025/10/19/web-cache2/image-20251020001232985.png" srcset="/img/loading.gif" lazyload></p>
<p>查看静态文件，看到了解析规则<img src="/2025/10/19/web-cache2/image-20251020001332616.png" srcset="/img/loading.gif" lazyload></p>
<p>结合跟页面的代码<img src="/2025/10/19/web-cache2/image-20251020001508617.png" srcset="/img/loading.gif" lazyload></p>
<p>于是在攻击者页面写入<img src="/2025/10/19/web-cache2/image-20251020001532956.png" srcset="/img/loading.gif" lazyload></p>
<p>（在头部添加<code>Access-Control-Allow-Origin: *</code>）CORS是为了防止<strong>恶意脚本未经授权访问其他域的资源和数据</strong></p>
<p>发包写入Cache即可</p>
<h3 id="实验室：结合-Web-缓存中毒漏洞"><a href="#实验室：结合-Web-缓存中毒漏洞" class="headerlink" title="实验室：结合 Web 缓存中毒漏洞"></a>实验室：结合 Web 缓存中毒漏洞</h3><p><img src="/2025/10/19/web-cache2/image-20251020004819824.png" srcset="/img/loading.gif" lazyload></p>
<p>进靶场，把根目录交给param Miner，随后直接能看到的是两个点</p>
<p>第一个：cookie，<img src="/2025/10/19/web-cache2/image-20251020010135230.png" srcset="/img/loading.gif" lazyload></p>
<p>注意到lang直接明文在cookie中，查看处理逻辑<img src="/2025/10/19/web-cache2/image-20251020010209338.png" srcset="/img/loading.gif" lazyload></p>
<p>第二个： 扫出      ‘x-forwarded-host~%s.%h’.    </p>
<p><img src="/2025/10/19/web-cache2/image-20251020010311507.png" srcset="/img/loading.gif" lazyload></p>
<p>后面大概就是根据\resources\js\translations.js代码解析json<img src="/2025/10/19/web-cache2/image-20251020010600701.png" srcset="/img/loading.gif" lazyload></p>
<p>审计一下这个js,(只取关键部分)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initTranslations</span>(<span class="hljs-params">jsonUrl</span>) <span class="hljs-comment">//处理cookie部分</span><br>&#123;<br>    <span class="hljs-keyword">const</span> lang = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;;&#x27;</span>)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>))<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;lang&#x27;</span>)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p[<span class="hljs-number">1</span>])<br>        .<span class="hljs-title function_">find</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>);<br><span class="hljs-title function_">fetch</span>(jsonUrl)  <span class="hljs-comment">//处理json数据</span><br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">j</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> select = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;lang-select&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (select) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> code <span class="hljs-keyword">in</span> j) &#123;<br>                <span class="hljs-keyword">const</span> name = j[code].<span class="hljs-property">name</span>;<br>                <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;option&quot;</span>);<br>                el.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;value&quot;</span>, code);<br>                el.<span class="hljs-property">innerText</span> = name;<br>                select.<span class="hljs-title function_">appendChild</span>(el);<br>                <span class="hljs-keyword">if</span> (code === lang) &#123;<br>                    select.<span class="hljs-property">selectedIndex</span> = select.<span class="hljs-property">childElementCount</span> - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        lang <span class="hljs-keyword">in</span> j &amp;&amp; lang.<span class="hljs-title function_">toLowerCase</span>() !== <span class="hljs-string">&#x27;en&#x27;</span> &amp;&amp; j[lang].<span class="hljs-property">translations</span> &amp;&amp; <span class="hljs-title function_">translate</span>(j[lang].<span class="hljs-property">translations</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;maincontainer&#x27;</span>)[<span class="hljs-number">0</span>]);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2025/10/19/web-cache2/image-20251020011838792.png" srcset="/img/loading.gif" lazyload></p>
<p>然后对比一下发现首页好像只有View details，于是尝试在这里做手脚</p>
<p><img src="/2025/10/19/web-cache2/image-20251020012614585.png" srcset="/img/loading.gif" lazyload></p>
<p>情况就是污染一个语言 然后对这个语言进行写Cache操作，但在测试时，读操作却出问题了，选不了语言了，只能使用默认的EN</p>
<p><img src="/2025/10/19/web-cache2/image-20251020012600278.png" srcset="/img/loading.gif" lazyload></p>
<p>碰到瓶颈，又看到切换语言时，有重定向操作<img src="/2025/10/19/web-cache2/image-20251020012900595.png" srcset="/img/loading.gif" lazyload></p>
<p>然后注意到目标里又扫到一个表头<img src="/2025/10/19/web-cache2/image-20251020013450157.png" srcset="/img/loading.gif" lazyload>看看这个标头有什么用</p>
<p><img src="/2025/10/19/web-cache2/image-20251020014022161.png" srcset="/img/loading.gif" lazyload></p>
<p><code>X-Original-Url</code> 是一个非标准的 HTTP 请求头，主要用于在代理服务器（如反向代理、负载均衡器）转发请求时，向后端服务器传递<strong>客户端原始请求的 URL 路径</strong>，解决代理转发过程中 URL 被修改导致的路径识别问题。</p>
<p>那肯定就想到把原始URL设置为我想要的en-gb</p>
<p><img src="/2025/10/19/web-cache2/image-20251020014926501.png" srcset="/img/loading.gif" lazyload></p>
<p>但是有set-cookies，用反斜杠成功了<img src="/2025/10/19/web-cache2/image-20251020015114611.png" srcset="/img/loading.gif" lazyload></p>
<p>看到这个重定向也有缓存，那就把地址污染和语言重定向一并写入&#x2F;目录的缓存，顺序重放两个请求,这样受害者就能同时读两个Cache</p>
<p><img src="/2025/10/19/web-cache2/image-20251020234237627.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="实验室：通过非密钥查询字符串进行-Web-缓存中毒"><a href="#实验室：通过非密钥查询字符串进行-Web-缓存中毒" class="headerlink" title="实验室：通过非密钥查询字符串进行 Web 缓存中毒"></a>实验室：通过非密钥查询字符串进行 Web 缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251021135837393.png" srcset="/img/loading.gif" lazyload></p>
<p>把首页抓包到repeater测试，当把GET &#x2F;?aa&#x3D;11放进内存时，再访问GET &#x2F;?aas&#x3D;11s读到了Cache，说明参数不在cache key里面</p>
<p><img src="/2025/10/19/web-cache2/image-20251021154310398.png" srcset="/img/loading.gif" lazyload></p>
<p>而同时发现参数会出现在响应中</p>
<p><img src="/2025/10/19/web-cache2/image-20251021154459096.png" srcset="/img/loading.gif" lazyload></p>
<p>就是利用cache rules会去掉参数，但服务器会解析参数并反射的特点，构造alert让受害者读入</p>
<p>我的构造：</p>
<p><img src="/2025/10/19/web-cache2/image-20251021154907912.png" srcset="/img/loading.gif" lazyload></p>
<p>验证，去掉参数确实还是能读到缓存</p>
<p><img src="/2025/10/19/web-cache2/image-20251021155045778.png" srcset="/img/loading.gif" lazyload></p>
<p>然后最后我们再看看提示说的标头<img src="/2025/10/19/web-cache2/image-20251021155530718.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="实验室：通过非密钥查询参数进行-Web-缓存中毒"><a href="#实验室：通过非密钥查询参数进行-Web-缓存中毒" class="headerlink" title="实验室：通过非密钥查询参数进行 Web 缓存中毒"></a>实验室：通过非密钥查询参数进行 Web 缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251021155931847.png" srcset="/img/loading.gif" lazyload></p>
<p>这次发现参数也会存入缓存，猜测UTM参数是被排除的参数，与此同时，param miner也扫出来了</p>
<p><img src="/2025/10/19/web-cache2/image-20251021160901496.png" srcset="/img/loading.gif" lazyload></p>
<p>说明cache rules自动屏蔽了UTM_content参数，这个参数通常是用于<strong>追踪网络营销活动的流量来源、媒介、内容等信息</strong></p>
<p><img src="/2025/10/19/web-cache2/image-20251021161505595.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="实验室：参数隐藏"><a href="#实验室：参数隐藏" class="headerlink" title="实验室：参数隐藏"></a>实验室：参数隐藏</h3><p><img src="/2025/10/19/web-cache2/image-20251021170747697.png" srcset="/img/loading.gif" lazyload></p>
<p>首先通过简单的测试知道了cache会检测参数保存，而且会对<code>&lt;&gt;</code>进行HTML编码。</p>
<p><img src="/2025/10/19/web-cache2/image-20251021175304760.png" srcset="/img/loading.gif" lazyload></p>
<p>扫head也没扫出东西 但是扫出无效参数<code>utm_content</code>，还扫出了参数隐藏，就是解析方式差异</p>
<p><img src="/2025/10/19/web-cache2/image-20251021172854852.png" srcset="/img/loading.gif" lazyload></p>
<p>猜测是服务器接受所有，Cache不解析分号<code>;</code></p>
<p>最后的测试：GET &#x2F;?utm_content&#x3D;1;a&#x3D;1的缓存用GET &#x2F; 能读到</p>
<p>但是考虑到上面测试位置对符号的编码，放弃这个位置，在下面找到了其他可用点，在访问主界面时会自动调用这个src</p>
<p><img src="/2025/10/19/web-cache2/image-20251021175414661.png" srcset="/img/loading.gif" lazyload></p>
<p>看看这个文件</p>
<p><img src="/2025/10/19/web-cache2/image-20251021180107389.png" srcset="/img/loading.gif" lazyload></p>
<p>那就想是不是可以受害者读到这个src的Cache，但我们对这进行污染，写入带有xss的缓存</p>
<p>发现可以通过编辑参数来控制对返回数据调用的函数的名称<code>callback</code></p>
<p><img src="/2025/10/19/web-cache2/image-20251021182615351.png" srcset="/img/loading.gif" lazyload></p>
<p>然后利用服务器针对同名参数会优先使用最后一个的特性，写一个缓存以为是callback&#x3D;setCountryCookie，实际上服务器写入的是callback&#x3D;alert(1)的poc</p>
<p><img src="/2025/10/19/web-cache2/image-20251021183403414.png" srcset="/img/loading.gif" lazyload></p>
<p>在服务器视角里就是解析为：utm_content&#x3D;1和callback&#x3D;alert(1)</p>
<p>在cache解析为：callback&#x3D;setCountryCookie</p>
<p>因为UTM被屏蔽掉，而且Cache不解析<code>;</code>，把它当作普通字符串作为了UTM的值，导致UTM开始的所有被Cache清楚了。</p>
<h3 id="实验：通过胖GET请求进行Web缓存中毒"><a href="#实验：通过胖GET请求进行Web缓存中毒" class="headerlink" title="实验：通过胖GET请求进行Web缓存中毒"></a>实验：通过胖GET请求进行Web缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251021184230894.png" srcset="/img/loading.gif" lazyload></p>
<p>测试下来本实验没有CAche不排除的参数，也没有分隔符解析问题</p>
<p>胖GET就是在GET请求的同时，直接用POST传参（或者覆盖）</p>
<p><img src="/2025/10/19/web-cache2/image-20251021200313309.png" srcset="/img/loading.gif" lazyload></p>
<p>有时候不能直接用胖Get，有些可以X-HTTP-Method-Override: POST覆盖</p>
<h3 id="实验室：URL-规范化"><a href="#实验室：URL-规范化" class="headerlink" title="实验室：URL 规范化"></a>实验室：URL 规范化</h3><p><img src="/2025/10/19/web-cache2/image-20251021201642529.png" srcset="/img/loading.gif" lazyload></p>
<p>任意访问不存在的文件，发现回显存在漏洞，似乎可以直接反射xss</p>
<p><img src="/2025/10/19/web-cache2/image-20251021203648428.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2025/10/19/web-cache2/image-20251021204732618.png" srcset="/img/loading.gif" lazyload></p>
<p>直接把xss写入缓存，然后发给服务器读缓存</p>
<p>即使服务器会编码这些语句阻止xss攻击，但是Cache可能会做规范化，自动解码，然后对上了之前写入的缓存</p>
<h3 id="实验：缓存键注入"><a href="#实验：缓存键注入" class="headerlink" title="实验：缓存键注入"></a>实验：缓存键注入</h3><p><img src="/2025/10/19/web-cache2/image-20251021213548810.png" srcset="/img/loading.gif" lazyload></p>
<p>首先发包主页面，发现是跳转页，且有缓存</p>
<p><img src="/2025/10/19/web-cache2/image-20251021214702490.png" srcset="/img/loading.gif" lazyload></p>
<p>加上pragma参数看看更多缓存信息，同时Param扫出了Cache忽略的参数utm_content，还有扫出<code>;</code>符号会被Cache识别为字符串。</p>
<p><img src="/2025/10/19/web-cache2/image-20251021214844498.png" srcset="/img/loading.gif" lazyload></p>
<p>看到标头里有个<code>Vary</code> 用于告诉缓存系统：<strong>“当前响应的内容会根据哪些请求头的不同而变化，请根据这些请求头来区分缓存”</strong></p>
<p>跟随跳转看看，</p>
<p><img src="/2025/10/19/web-cache2/image-20251021215204347.png" srcset="/img/loading.gif" lazyload></p>
<p>发现参数直接回显到相应，那第一时间就试试直接构造xss，但是被HTML编码了，而且目前不加入缓存</p>
<p><img src="/2025/10/19/web-cache2/image-20251021215251132.png" srcset="/img/loading.gif" lazyload></p>
<p>于是加上<code>origin</code>到原本有缓存机制的地方看看，这后面一定用得上</p>
<p><img src="/2025/10/19/web-cache2/image-20251022000832522.png" srcset="/img/loading.gif" lazyload></p>
<p>没辙了，找找有没有其他静态文件，找到js&#x2F;localize.js，并且发现可以根据更改参数控制响应脚本（但是）</p>
<p><img src="/2025/10/19/web-cache2/image-20251022001511224.png" srcset="/img/loading.gif" lazyload></p>
<p>加上前面找到的header看看</p>
<p><img src="/2025/10/19/web-cache2/image-20251022001945132.png" srcset="/img/loading.gif" lazyload></p>
<p>到现在总结一下有用的东西：1.排除的参数utm_content ； 2.Cache不识别<code>;</code> 3.Oringe可加入Cache key 4.有用的header：Pragma: x-get-cache-key 5.utm参数后面的编码会被cache当做普通字符，服务器会解析</p>
<p><img src="/2025/10/19/web-cache2/image-20251022131241426.png" srcset="/img/loading.gif" lazyload><img src="/2025/10/19/web-cache2/image-20251022133014385.png" srcset="/img/loading.gif" lazyload><img src="/2025/10/19/web-cache2/image-20251022133043230.png" srcset="/img/loading.gif" lazyload></p>
<p>于是就是先想办法把响应构造成alert(1),先把参数cors改为1（可能就能运行跨域请求），</p>
<p>然后原来的key下面还有个content-len 我们伪造一下，就是注入origin&#x3D;x<code>\r\n</code>Content-Length: 8<code>\r\n</code>alert(1)</p>
<p><img src="/2025/10/19/web-cache2/image-20251022005137856.png" srcset="/img/loading.gif" lazyload></p>
<p>后面就是考虑怎么存入这个Cache的同时，利用差异让受害者正常访问但是确实踩到这个Cache</p>
<p>就是缓存以为是lang&#x3D;en&amp;cors&#x3D;0    我给服务器的得是cors&#x3D;1</p>
<p>根据上面的构造条件，最后重新理一下思路：</p>
<ol>
<li>首先就是先构造Cache key注入，让js文件变成xss文件：就是添加origin伪造响应body：</li>
</ol>
<p><img src="/2025/10/19/web-cache2/image-20251022142539263.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li><p>随后是利用重定向文件，让Cache key还是受害者都会访问的<code>/login?lang=en$$</code> 但定位到的地址得是能访问到我们写入xss js文件的网页。</p>
<p>那就利用cacherules排除utm_content的机制，让重定向请求是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">GET</span> /login?lang=en?utm_content=x%26cors=<span class="hljs-number">1</span>$$origin=x%250d%250aContent-<span class="hljs-title class_">Length</span>:%<span class="hljs-number">208</span>%250d%250a%250d%250aalert(<span class="hljs-number">1</span>)%<span class="hljs-number">23</span> <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><img src="/2025/10/19/web-cache2/image-20251022143132989.png" srcset="/img/loading.gif" lazyload></p>
<p>这里就是成功做到了 cache完全忽略了utm后面的所有，但服务器重定向能过去</p>
<p>看看重定向的网页下面</p>
<p><img src="/2025/10/19/web-cache2/image-20251022143359296.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>但是这个js路径并不是我最开始写入Cache的那个路径，回头重新改一下js的cache key，其实可以先看一下浏览器怎么处理</p>
<p><img src="/2025/10/19/web-cache2/image-20251022144056001.png" srcset="/img/loading.gif" lazyload></p>
<p>然后用一样的路径写入一下，其实就是加一个utm_content</p>
<p><img src="/2025/10/19/web-cache2/image-20251022143601254.png" srcset="/img/loading.gif" lazyload></p>
<p>我们这里可以看到 其实就是key里是<code>?cors</code> 但是直接改&amp;为?是不行的，因为服务器不会把第二个问号解析问参数。直接用上面浏览器的处理方式写缓存就行了</p>
<p>两个细节：</p>
<ol>
<li>二次编码<img src="/2025/10/19/web-cache2/image-20251022145502171.png" srcset="/img/loading.gif" lazyload></li>
<li>为什么是origin&#x3D;不是origin：</li>
</ol>
</li>
</ol>
<h3 id="实验室：内部缓存中毒"><a href="#实验室：内部缓存中毒" class="headerlink" title="实验室：内部缓存中毒"></a>实验室：内部缓存中毒</h3><p><img src="/2025/10/19/web-cache2/image-20251022224243100.png" srcset="/img/loading.gif" lazyload></p>
<p>看到有陌生文件，同时找到与其有联系的静态文件resources&#x2F;js&#x2F;analytics.js</p>
<p><img src="/2025/10/19/web-cache2/image-20251022224322649.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2025/10/19/web-cache2/image-20251022224333102.png" srcset="/img/loading.gif" lazyload></p>
<p>审计一下源码，是随机生成16位字符串，然后param miner扫出了标头</p>
<p><img src="/2025/10/19/web-cache2/image-20251022230955752.png" srcset="/img/loading.gif" lazyload></p>
<p>然后测试一下看看有什么用</p>
<p><img src="/2025/10/19/web-cache2/image-20251022235502970.png" srcset="/img/loading.gif" lazyload></p>
<p>会在响应里回显，最先尝试了构造注入，但是没用。</p>
<p>重新抓一个包，改成我们的攻击者服务器，发几次包</p>
<p><img src="/2025/10/19/web-cache2/image-20251022235635261.png" srcset="/img/loading.gif" lazyload></p>
<p>发现js&#x2F;geolocate.js的路劲被覆盖了。等于是可以用我们的服务器写入缓存了</p>
<p><img src="/2025/10/19/web-cache2/image-20251022235722362.png" srcset="/img/loading.gif" lazyload></p>
<p>这里有个blog写的不错，有参考:</p>
<p>​	<a target="_blank" rel="noopener" href="https://zrquan.github.io/posts/web-cache/">存储投毒</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/web%E5%AE%89%E5%85%A8%E4%B8%93%E9%A2%98/" class="category-chain-item">web安全专题</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>web缓存中毒</div>
      <div>https://i4g5d.github.io/2025/10/19/web-cache2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>i4G5d</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/15/web-cache/" title="web缓存欺骗">
                        <span class="hidden-mobile">web缓存欺骗</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
